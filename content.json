{"pages":[{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"10.正则表达式匹配","text":"原题地址：https://leetcode-cn.com/problems/regular-expression-matching/submissions/ 解法1: 递归12345678910111213class Solution(object): def isMatch(self, text, pattern): # 判断是不是一样长 if not pattern: return not text # text不为空且p与其匹配 first_match = bool(text) and pattern[0] in {text[0], '.'} if len(pattern) &gt;= 2 and pattern[1] == '*': return (self.isMatch(text, pattern[2:]) or first_match and self.isMatch(text[1:], pattern)) else: return first_match and self.isMatch(text[1:], pattern[1:])","link":"/2019/11/06/10.%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"},{"title":"11.盛最多水的容器","text":"原题地址：https://leetcode-cn.com/problems/container-with-most-water/ 解法1: 暴力12345678910111213141516171819class Solution {public: int maxArea(vector&lt;int&gt;&amp; height) { int max = 0; int temp = 0; if(height.size() &lt;= 1) return 0; for(int i = 0; i &lt; height.size(); ++i) { for(int j = i + 1; j &lt; height.size(); ++j) { temp = (height[i] &lt; height[j] ? height[i] : height[j]) * (j - i); max = temp &gt; max ? temp : max; } } return max; }}; 解法2: 双指针法思路：两个指针分别指向数组两头，每次都移动值较小的指针，只有这样才可能弥补底边变短带来的面积减小。注意：容器大小由较短的边决定 123456789101112131415class Solution {public: int maxArea(vector&lt;int&gt;&amp; height) { int maxarea = 0, l = 0, r = height.size() - 1; while (l &lt; r) { maxarea = max(maxarea, min(height[l], height[r]) * (r - l)); if (height[l] &lt; height[r]) l++; else r--; } return maxarea; }};","link":"/2019/11/06/11.%20%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/"},{"title":"17.电话号码的字母组合","text":"题目地址：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/submissions/ 解法1:思路：递归 python: 1234567891011121314151617181920212223242526class Solution: def letterCombinations(self, digits): \"\"\" :type digits: str :rtype: List[str] \"\"\" phone = {'2': 'abc', '3': 'def', '4': 'ghi', '5': 'jkl', '6': 'mno', '7': 'pqrs', '8': 'tuv', '9': 'wxyz'} def backtrack(combination, next_digits): if len(next_digits) == 0: output.append(combination) else: for letter in phone[next_digits[0]]: backtrack(combination + letter, next_digits[1:]) output = [] if digits: backtrack(\"\", digits) return output c++: 1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: vector&lt;string&gt; letterCombinations(string digits) { vector&lt;string&gt; res;//用于输出向量 map&lt;char, string&gt; m = { {'2',\"abc\" },{'3',\"def\"},{'4',\"ghi\"},{'5',\"jkl\"},{'6',\"mno\"},{'7',\"pqrs\"},{'8',\"tuv\"},{'9',\"wxyz\"} };//映射map哈希表 int size = digits.size();//输入字符串产长度 queue&lt;string&gt; que;//新建队列 //先将第一个元素对应的码表入队 for (int j = 0; j &lt; m[digits[0]].size(); j++) { string str; str.push_back(m[digits[0]][j]);//char转string que.push(str);//string入队 } string s;//用于存储队头元素 for (int i = 1; i &lt; size; i++) { int length = que.size();//当前队列长度 while (length--) { for (int j = 0; j &lt; m[digits[i]].size(); j++) { s = que.front(); s = s + m[digits[i]][j];//队头元素加上新元素 que.push(s);//入队 } que.pop();//队头出队 } } while (!que.empty()) { res.push_back(que.front());//队头元素存储至res que.pop();//队头出队 } return res;//返回 }};","link":"/2019/11/06/17.%20%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88/"},{"title":"31.下一个排列","text":"原题地址：https://leetcode-cn.com/problems/next-permutation/submissions/ ###解法1: 一遍扫描 思路如图 12345678910111213141516171819202122232425262728293031class Solution {public: void nextPermutation(vector&lt;int&gt;&amp; nums) { int i = nums.size() - 2; while (i &gt;= 0 &amp;&amp; nums[i + 1] &lt;= nums[i]) i--; if (i &gt;= 0) { int j = nums.size() - 1; while (j &gt;= 0 &amp;&amp; nums[j] &lt;= nums[i]) j--; swap(nums, i, j); } reverse(nums, i + 1); } void reverse(vector&lt;int&gt;&amp; nums, int start) { int i = start, j = nums.size() - 1; while (i &lt; j) { swap(nums, i, j); i++; j--; } } void swap(vector&lt;int&gt;&amp; nums, int i, int j) { int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; }}; 解法2: STL123456class Solution {public: void nextPermutation(vector&lt;int&gt;&amp; nums) { next_permutation(nums.begin(),nums.end()); }};","link":"/2019/11/21/31.%E4%B8%8B%E4%B8%80%E4%B8%AA%E6%8E%92%E5%88%97/"},{"title":"23.合并K个排序链表","text":"原题地址：https://leetcode-cn.com/problems/merge-k-sorted-lists/submissions/ 解法1: 暴力法将value从链表中取出到容器，然后再新建一个链表 1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { vector&lt;int&gt; num; if(!lists.size()) return NULL; if(lists.size() == 1) return lists[0]; for(auto list : lists) { while(list != NULL) { num.push_back(list-&gt;val); list = list-&gt;next; } } if(!num.size()) return NULL; sort(num.begin(), num.end()); ListNode *res = new ListNode(num[0]); ListNode *ress = res; for(int i = 1; i &lt; num.size(); ++i) { res-&gt;next = new ListNode(num[i]); res = res-&gt;next; } return ress; }}; 解法2: 合并链表将问题简化为执行k-1次合并两个链表操作 123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if(l1 == nullptr) return l2; if(l2 == nullptr) return l1; if(l1-&gt;val &lt; l2-&gt;val){ l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; }else{ l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; } } ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { if(!lists.size()) return NULL; if(lists.size() == 1) return lists[0]; ListNode *res = NULL; for(int i = 0; i &lt; lists.size(); ++i) res = mergeTwoLists(res, lists[i]); return res; }}; 这里有一个问题是，在for中res的迭代会造成大量重复的链表元素比较，所以我们采用queue替换vector，并将每次合并后的链表插到queue尾部，从而减小重复计算。 优化后： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) { if(l1 == nullptr) return l2; if(l2 == nullptr) return l1; if(l1-&gt;val &lt; l2-&gt;val){ l1-&gt;next = mergeTwoLists(l1-&gt;next, l2); return l1; }else{ l2-&gt;next = mergeTwoLists(l1, l2-&gt;next); return l2; } } ListNode* mergeKLists(vector&lt;ListNode*&gt;&amp; lists) { if(!lists.size()) return NULL; if(lists.size() == 1) return lists[0]; queue&lt;ListNode*&gt; q; for(int i = 0; i &lt; lists.size(); ++i) q.emplace(lists[i]); ListNode* t1 = NULL; ListNode* t2 = NULL; for(int i = 0; q.size() &gt; 1; ++i) { t1 = q.front(); q.pop(); t2 = q.front(); q.pop(); q.emplace(mergeTwoLists(t1, t2)); } return q.front(); }};","link":"/2019/11/20/23.%20%E5%90%88%E5%B9%B6K%E4%B8%AA%E6%8E%92%E5%BA%8F%E9%93%BE%E8%A1%A8/"},{"title":"19.删除链表的倒数第N个节点","text":"原题地址：https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/ 解法1: 双指针1234567891011121314151617181920212223242526272829/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public: ListNode* removeNthFromEnd(ListNode* head, int n) { ListNode* pre = head; ListNode* cur = head; while(cur-&gt;next) { if(--n &lt; 0) pre = pre-&gt;next; cur = cur-&gt;next; } if(pre == head &amp;&amp; n == 1) return head-&gt;next; else { pre-&gt;next = pre-&gt;next-&gt;next; return head; } }}; 解法2: 遍历两遍略。","link":"/2019/11/07/19.%20%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%ACN%E4%B8%AA%E8%8A%82%E7%82%B9/"},{"title":"22.括号生成","text":"原题地址：https://leetcode-cn.com/problems/generate-parentheses/ 解法1: 计数法思路：根据规律得到，若将( 视为1，)视为-1，那么有效的括号组合中任意前几个括号的和都&gt;=0，所以只需要遍历括号串判断过程中是否全部大于0即可。 注意：next_permutation的用法，需要原字符串从小到大排列，且结果不包含原字符串 12345678910111213141516171819202122232425262728293031323334353637class Solution {public: vector&lt;string&gt; generateParenthesis(int n) { vector&lt;string&gt; res; string s = \"\"; int judge = 0; bool flag; int temp = n; while(temp--) s.append(\"(\"); temp = n; while(temp--) s.append(\")\"); res.push_back(s); while(next_permutation(s.begin(), s.end())) { flag = true; judge = 0; for(int i = 0; i &lt; s.size(); ++i) { if(s[i] == '(') ++judge; else --judge; if(judge &lt; 0) { flag = false; break; } } if(flag) res.push_back(s); } return res; }};","link":"/2019/11/07/22.%20%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"},{"title":"5.最长回文子串","text":"原题地址：https://leetcode-cn.com/problems/longest-palindromic-substring/ 犯的错误： 忽略了最长的前提 解法1: 暴力法123456789101112131415161718192021class Solution {public: string longestPalindrome(string s) { string temp = \"\"; string res = \"\"; for(int i = 0; i &lt; s.length(); ++i) { for(int j = i; j &lt; s.length(); ++j) { temp += s[j]; string tempr = temp; std::reverse(tempr.begin(), tempr.end()); if(temp == tempr) if(res.length() &lt; temp.length()) res = temp; } temp = \"\"; } return res; }}; 会超时。 解法2: 动态规划dp[i][j]: 从字符串第i个字符到第j个字符之间的字符串是否为回文子串 12345678910111213141516171819202122232425262728293031323334353637class Solution {public: string longestPalindrome(string s) { if(s.length() == 0 || s.length() == 1) return s; int start = 0; int max = 1; vector&lt;vector&lt;int&gt;&gt; dp(s.length(), vector&lt;int&gt;(s.length())); for(int i = 0; i &lt; s.length(); ++i) { dp[i][i] = 1; //找出长度为2的回文子串 if( (i + 1 &lt; s.length() ) &amp;&amp; (s[i] == s[i+1]) ) { dp[i][i+1] = 1; max = 2; start = i; } } //从长度为3的回文子串开始找 for(int l = 3; l &lt;= s.length(); ++l) { for(int i = 0; i + l - 1 &lt; s.length(); ++i) { int j = i + l - 1; if(s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]) { dp[i][j] = 1; start = i; max = l; } } } return s.substr(start, max); }}; 解法3：中心扩展法即把所有元素（两个元素）都尝试作为中心向外扩展，并记录最长回文子串的长度和起始位置。 12345678910111213141516171819202122232425262728293031323334353637class Solution {public: string longestPalindrome(string s) { int len=s.size(); if(len==0||len==1) return s; int start=0;//记录回文子串起始位置 int end=0;//记录回文子串终止位置 int mlen=0;//记录最大回文子串的长度 for(int i=0;i&lt;len;i++) { int len1=expendaroundcenter(s,i,i);//一个元素为中心 int len2=expendaroundcenter(s,i,i+1);//两个元素为中心 mlen=max(max(len1,len2),mlen); if(mlen&gt;end-start+1) { start=i-(mlen-1)/2; end=i+mlen/2; } } return s.substr(start,mlen); //该函数的意思是获取从start开始长度为mlen长度的字符串 }private: int expendaroundcenter(string s,int left,int right) //计算以left和right为中心的回文串长度 { int L=left; int R=right; while(L&gt;=0 &amp;&amp; R&lt;s.length() &amp;&amp; s[R]==s[L]) { L--; R++; } return R-L-1; }};","link":"/2019/11/05/5.%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E5%AD%90%E4%B8%B2/"},{"title":"8.字符串转换整数","text":"原题地址：https://leetcode-cn.com/problems/string-to-integer-atoi/ 犯的错误： 忽略了+ 忘记初始化i 解法1:12345678910111213141516171819202122232425262728293031323334353637383940414243class Solution {public: int myAtoi(string str) { bool isfirst = true; bool ispos = true; long long res = 0; int i = 0; while(str[i] == ' ') ++i; if(str[i] == '-') { isfirst = false; ispos = false; ++i; } else if(str[i] == '+') { isfirst = false; ++i; } for(;i &lt; str.size(); ++i) { //isdigit比直接判断竟然慢很多 if(str[i] &gt;= '0' &amp;&amp; str[i] &lt;= '9') { res = res * 10 + str[i] - '0'; if(res &gt; INT_MAX) { if(!ispos &amp;&amp; res == INT_MAX + 1) return -res; else return ispos?INT_MAX:INT_MIN; } } else break; } return ispos?res:-res; }};","link":"/2019/11/06/8.%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%95%B4%E6%95%B0/"},{"title":"6.Z字形变换","text":"原题地址：https://leetcode-cn.com/problems/zigzag-conversion/ 解法1: 遍历通过找规律发现第一行和最后一行有共性，其余行有共性。 1234567891011121314151617181920212223242526272829303132333435363738class Solution {public: string convert(string s, int numRows) { int len = s.length(); string res = \"\"; if(numRows == 1 || len == 0 || len == 1) return s; // res.push_back(s[0]); for(int num = 1; num &lt;= numRows; ++num) { if(num == 1 || num == numRows) { for(int i = num - 1; i &lt; len; i += 2 * (numRows - 1)) res.push_back(s[i]); } else { bool flag = true; for(int i = num - 1; i &lt; len;) { if(flag) { res.push_back(s[i]); i = i + 2 * (numRows - 2) - 2 * (num - 2); flag = false; } else { res.push_back(s[i]); i = i + 2 * (num - 1); flag = true; } } } } return res; }}; 解法2: 按行排序思路：建立一个数组，按行将字符排序，最后合并 123456789101112131415161718192021class Solution {public: string convert(string s, int numRows) { if (numRows == 1) return s; vector&lt;string&gt; rows(min(numRows, int(s.size()))); int curRow = 0; bool goingDown = false; for (char c : s) { rows[curRow] += c; if (curRow == 0 || curRow == numRows - 1) goingDown = !goingDown; curRow += goingDown ? 1 : -1; } string ret; for (string row : rows) ret += row; return ret; }};","link":"/2019/11/05/6.Z%E5%AD%97%E5%BD%A2%E5%8F%98%E6%8D%A2/"},{"title":"Hello My Blog","text":"用来记录一下生活和搬砖过程中遇到和解决的问题","link":"/2019/10/01/Hello%20My%20Blog/"},{"title":"C++11新特性——匿名函数(lambda)","text":"简介 C++11提供了对匿名函数的支持,称为Lambda函数(也叫Lambda表达式). Lambda表达式具体形式如下: [capture](parameters)-&gt;return-type{body} 如果没有参数,空的圆括号()可以省略.返回值也可以省略,如果函数体只由一条return语句组成或返回类型为void的话.形如: [capture](parameters){body} 下面举了几个Lambda函数的例子: 1234[](int x, int y) { return x + y; } // 隐式返回类型[](int&amp; x) { ++x; } // 没有return语句 -&gt; lambda 函数的返回类型是'void'[]() { ++global_x; } // 没有参数,仅访问某个全局变量[]{ ++global_x; } // 与上一个相同,省略了() 可以像下面这样显示指定返回类型: 1[](int x, int y) -&gt; int { int z = x + y; return z; } 在这个例子中创建了一个临时变量z来存储中间值. 和普通函数一样,这个中间值不会保存到下次调用. 什么也不返回的Lambda函数可以省略返回类型, 而不需要使用 -&gt; void 形式. Lambda函数可以引用在它之外声明的变量. 这些变量的集合叫做一个闭包. 闭包被定义在Lambda表达式声明中的方括号[]内. 这个机制允许这些变量被按值或按引用捕获.下面这些例子就是: 123456[] //未定义变量.试图在Lambda内使用任何外部变量都是错误的.[x, &amp;y] //x 按值捕获, y 按引用捕获.[&amp;] //用到的任何外部变量都隐式按引用捕获[=] //用到的任何外部变量都隐式按值捕获[&amp;, x] //x显式地按值捕获. 其它变量按引用捕获[=, &amp;z] //z按引用捕获. 其它变量按值捕获 例子遍历一个vector时，传统： 12345678int main() { vector&lt;int&gt; v; v.push_back(1); v.push_back(2);//... for ( auto itr = v.begin(), end = v.end(); itr != end; itr++ ) cout &lt;&lt; *itr; } Lambda: 123456789int main() { vector&lt;int&gt; v; v.push_back(1); v.push_back(2);//... for_each(v.begin(), v.end(), [](int val) { cout &lt;&lt; val; });}","link":"/2019/11/11/C++11%E6%96%B0%E7%89%B9%E6%80%A7%E2%80%94%E2%80%94%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0(lambda)/"}],"tags":[{"name":"匹配","slug":"匹配","link":"/tags/%E5%8C%B9%E9%85%8D/"},{"name":"字符串","slug":"字符串","link":"/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"排列组合","slug":"排列组合","link":"/tags/%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"合并","slug":"合并","link":"/tags/%E5%90%88%E5%B9%B6/"},{"name":"穷举","slug":"穷举","link":"/tags/%E7%A9%B7%E4%B8%BE/"},{"name":"C++11","slug":"C-11","link":"/tags/C-11/"},{"name":"lambda","slug":"lambda","link":"/tags/lambda/"}],"categories":[{"name":"leetcode","slug":"leetcode","link":"/categories/leetcode/"},{"name":"C++11","slug":"C-11","link":"/categories/C-11/"}]}